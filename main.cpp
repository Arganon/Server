#include <fcntl.h>
#include <iostream>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <algorithm>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "paramparser.h"
#include "logger.h"
#include "server.h"


void run_server(const Data &_data) {
    int pid_num = open("a.pid", O_RDONLY);

    if (pid_num > 0) {
        LOG(LOG_LVL::LOGS::DEBUG, "Daemon is already works\n");
        exit(EXIT_FAILURE);
    }
    Server server(_data);
    server.run();
}

void print_help() {
    std::cout << "The list of the commands:\n-h or --help to get this list." << std::endl;
    std::cout << "-r or --run to run the server." << std::endl;
    std::cout << "-p or --port to set the listen port for the server." << std::endl;
    std::cout << "-a or --adr to set the host for the server." << std::endl;
    std::cout << "-s or --stop to stop the server." << std::endl;
}

void stop_process() {
    int del_pid_file = remove("a.pid");
    exit(EXIT_SUCCESS);
}

void stop_daemon(pid_t pid) {
    int len;
    char pid_buf[20];
    int pid_num = open("a.pid", O_RDONLY);
    if (pid != 0) {
        len = read(pid_num, pid_buf, 16);
        pid_buf[len] = 0;
        pid = atoi(pid_buf);
        kill(pid, SIGUSR2);
        stop_process();
    } else {
        exit(EXIT_FAILURE);
    }
}

void set_pid(pid_t pid) {
    pid = fork();
    if (pid != 0) {
        FILE *pid_file = fopen("a.pid", "w");	/* file where we writing daemon process number */
        fprintf(pid_file, "%d\n", pid);
    }
    if (pid < 0) {
        stop_process();
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }
}

void set_sid(pid_t sid) {
    sid = setsid();

    if (sid < 0) {
        LOG(LOG_LVL::LOGS::DEBUG, "Can't start Daemon.\n");
        stop_process();
        exit(EXIT_FAILURE);
    }
}

void detach_server_process(const Data _data, pid_t _pid, pid_t _sid) {
    int pid_num = open("a.pid", O_RDONLY);

    if (pid_num > 0) {
        LOG(LOG_LVL::LOGS::DEBUG, "Daemon is already works\n");
        exit(EXIT_FAILURE);
    } else {
        set_pid(_pid);
        umask(0);		/* full access to the files generated by the daemon */
        set_sid(_sid);
        Server server(_data);
        server.run();
        stop_process();
        exit(EXIT_SUCCESS);
    }
}

void command_handler(COMMANDS _command, const Data &_data) {
    pid_t pid, sid;
    switch (_command) {
    case COMMANDS::RUN:
        run_server(_data);
        break;
    case COMMANDS::STOP:
        stop_daemon(pid);
        break;
    case COMMANDS::HELP:
        print_help();
        break;
    case COMMANDS::DAEMON:
        detach_server_process(_data, pid, sid);
        break;
    case COMMANDS::UNDEFINED:
        exit(EXIT_FAILURE);
        break;
    }
}

int main(int argc,char *argv[]) {

    if (argc > 1) {
        Data data;
        ParamParser param_parser;
        auto command = param_parser.parse_params(argc, argv, data);
        command_handler(command, data);
    } else {
        printf("Please, add parameters.\n");
        print_help();
        exit(EXIT_FAILURE);
    }

    return 0;
}









